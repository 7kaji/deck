# diffSlides 改善計画

## 目的

現在の `diffSlides` の実装を大幅に改訂することで、わかりやすく正確な機能を提供する

## 既存実装のまま維持しないといけないもの

- actionType
- deck.go にあるコード全て

## 前提

- 既存のdiffSlidesの実装は完全に無視します。

## アルゴリズム

以下の手順で `before` から `after` に変換するためのactionを生成します。

### 1. 初期化

`after` のスライドには *Slide と 現時点での index を使って、ユニークなキーを作成する。
`after` の全てのスライド（キー）とそのindexをトラッキングして、正しくアクションを生成するための情報を保持する（便宜上Stateと呼ぶ）

### 2. マッピング

割り当てアルゴリズムとしてはハンガリアンアルゴリズムを採用する。

まず、`before` と `after` のスライド数が異なる場合はハンガリアンアルゴリズムを適用するための同数調整をする。

- `after` のスライド数が小さい場合は、まず、`before` の各スライドについて `after` の全スライドとの getSimilarity によるスコアの合計を算出し、スコアの小さい `before` のスライドから順に `after` の末尾にappendして数を同数にする。
- `after` のスライド数が大きい場合は、まず、`after` の各スライドについて `before` の全スライドとの getSimilarity によるスコアの合計を算出し、スコアの小さい `after` のスライドから順に削除する。

このとき、上記のように `after` が操作されるのでそのactionとindexの変化はStateで記録する。

注意しなければならないのが、Google Slides APIを使用してmoveアクションを実施すると、つど各スライドのindexが更新されることだ。そのためのStateを設計すること。

この時点で`before` と `after` のスライドは同じ数になる

ここから、 `before` と `after` のスライドをそれぞれ getSimilarityForMapping で比べて、スコアの合計が最も高い形でスライドを1:1でマッピングする。このとき、割り当てアルゴリズムとしハンガリアンアルゴリズムを使用する。

### 3. ソート

この時点で、`before` と `after` のスライドは同じ数で、かつ1:1でマッピングされている。
ここで、`before` の各スライドとマッピングされている `after` の各スライドのindexを `before` のそれと一致させるようなmoveアクションを生成し、その上でつどStateを更新する。

注意しなければならないのが、Google Slides APIを使用してmoveアクションを実施すると、つど各スライドのindexが更新されることだ。そのためのStateを設計すること。

例えば `before` がA B の2つのスライドで、`after` が B A の2つのスライドのとき、Google Slides APIを考慮すると、「Aのスライドをindex 0からindex 1へmoveするアクションを1つだけ」もしくは「Bのスライドをindex 1からindex 0へmoveするアクションを1つだけ」で済む。なぜならmove後に各スライドのindexが更新されるので、1つのmoveアクションを実行後にBもAも意図したindexになる。

### 4. 更新

`before` のスライドとのgetSimilarityによる類似度ポイントが500以上ではない `after` の各スライドに updateアクションを生成する。

## 注意点

注意しなければならないのが、Google Slides APIを使用してmoveアクションを実施すると、つど各スライドのindexが更新されることだ。そのためのStateを設計すること。

## 成功指標

1. まず既存テストケースが全て通るようになること。 `make test` で実行可能
